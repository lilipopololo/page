---
layout: post
title: react探寻
category: blog
description: 写博客这个这么古老的行为，还有必要拿出来说吗，我看有。
---

# 大部分react应用在web平台上，react native 和react vr在其他平台上。


## react应用的主要成分
### 组件
- 组件是用户界面的一部分，比如导航。也可以担任数据格式化的职责。组件具有良好的封装性、复用性、组合性，使用react构建应用就像使用积木搭建项目，而在react中组件组合是最为强大的部分之一。react核心库和react-dom和react native精密结合，react dom针对浏览器渲染页面。而react native为ios和android等原生平台构建应用。
```
<body>
    <div id="root">
        <!-- 此元素的内容将替换为您的组件 -->
    </div>

    <!-- react 库  -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <!-- 用于处理 Dom 的 react 包 -->
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- 使用 PropTypes 进行类型检查 -->
    <script src="https://unpkg.com/prop-types@15.6/prop-types.js"></script>

    <script>
        const reactElem = React.createElement(
            'h1',
            {title: 'i am h1'},
            'Hello, world!'
        )
        ReactDOM.render(
            reactElem,
            document.getElementById('root')
        );
    </script>
</body>
```
- 上面的代码中，reactjs是react的核心库，用于定义组件规范，reactdom是渲染器用于创建组件和管理组件。proptypes传递给组件的数据做类型检查。React.createElement创建了一个react元素。
```
React.createElement(
  type,
  [props],
  [...children]
)
```
- 然后使用ReactDom.render将创建的react元素渲染到div#root中
- react使用虚拟dom挂在到真实的dom中。而react通过将全部 children 属性进行求值，并将结果传递给父元素的方式，对虚拟dom中的所有结构的每个细节构建为一棵完整的树，
- react除了需要 拓展元素的功能演示和其他UI相关，需要使用到react组件，组件相比于react元素拥有更多的特性，React.Component是将react元素和函数组织到一起的类。
```
class MyComponent extends React.Component {
    // 必须定义 render()。否则会报错：
    // MyComponent(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.
    render() {
        // 返回单个 React 元素或 React 元素的数组
        return reactElem
    }
}
```
每个组件知道需要定义一个render()方法，几乎任何向屏幕显示内容的组件都带有render方法。
```
<script>
    class MyComponent extends React.Component{
        render(){
            const c = React.createElement
            return React.createElement(
                'div',
                {},
                c('h2', {}, this.props.cnt1),
                c('a', {href: 'www.baidu.com'}, 'go baidu'),
                // class 属性在需要改为 className 
                c('p', {className: this.props.aClass}, 
                    c('em', {}, this.props.cnt2)
                )
            )
        }
    }
</script>
<script>
    // createElement 第一个参数可以是标签名字符串（如 'div' 或 'span'），也可以是 React 组件 类型 （class 组件或函数组件），或是 React fragment 类型
    const App = React.createElement(MyComponent, {
        cnt1: 'i am h2',
        aClass: 'p-class',
        cnt2: 'a am em element'
    })
    ReactDOM.render(
        App,
        document.getElementById('root')
    );
</script>
```
显示的结果如下,其中this.props获取了传递的属性。

```
<div>
    <h2>i am h2</h2>
    <a href="www.baidu.com">go baidu</a>
    <p class="p-class">
        <em>a am em element</em>
    </p>
</div>
```

react的MyComponent没有初始化this.props,并不是自己没有初始化，而是父类帮忙进行初始化了。一般在js和java中获取父类的构造器并获取数据需要使用super()，否则就会报错。
```
// 控制台输入如下代码，报错
// Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
// Uncaught ReferenceError：在访问“this”或从派生构造函数返回之前，必须在派生类中调用超级构造函数,否则就会报错
class A{}
class B extends A{
    constructor(){
       
    }
}
let b = new B()
```
- 如果不初始化state或不进行方法绑定，则不需要为react实现构造函数。通常，构造函数用于下面两种情况：1. 通过this.state 赋值对象来初始化内部state2.为事件函数绑定实例
- 类型检测，通过组件创建html元素，并利用propType验证所使用的属性。
```
<script>
    class MyComponent extends React.Component {
        ...
    }

    // 属性类型
    MyComponent.propTypes = {
        cnt1: PropTypes.number,
        // 注：函数不是 function，而是 func
        // 函数类型，并且必填
        func: PropTypes.func.isRequired
    }
    // 默认值
    MyComponent.defaultProps = {
        cnt1: 'defaultName'
    }
</script>
```

